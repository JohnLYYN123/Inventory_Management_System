
# Inventory Management System – Final Project Report

## Team Information

- **Yang Chen** (999551783) – student1@example.com  
- **Yihang Lin** (1006130447) – student2@example.com  
- **Yilei Ji** (1009219329) – student3@example.com  
- **Chujing Yu** (1010809608) – student4@example.com  

## Motivation

Modern hardware teams require a streamlined way to manage and track their equipment inventory. An **Inventory Management System (IMS)** is an essential tool to efficiently organize hardware resources and ensure that the right devices are available at the right time. Traditionally, inventory tracking has relied on manual records or disjointed spreadsheets, which often leads to **inaccuracies, overstocking or stockouts, and wasted resources**. These outdated practices can cause operational delays and miscommunication within the team.

Implementing a centralized IMS addresses these challenges by providing **real-time visibility** into stock levels, usage patterns, and replenishment needs. By automating manual processes, the system improves efficiency and allows the hardware team to focus on more strategic tasks instead of paperwork. It also reduces human errors through automated tracking and maintains a clear audit trail of all inventory movements for accountability. In addition, the IMS can generate useful data insights (e.g. usage reports) to support better decision-making in procurement and planning. Overall, pursuing this project is a strategic investment that **modernizes inventory handling**, prevents resource bottlenecks, and supports the organization’s growth. It benefits all stakeholders involved in hardware management – from engineers and lab technicians to procurement managers and project leads – by ensuring hardware resources are managed efficiently and transparently.

## Objectives

The project’s goal is to develop a robust, user-friendly IMS that meets the needs of the hardware team. Key objectives include:

- **User Management:** Enable user registration and authentication, with **role-based access control** for different types of users (e.g. regular users vs. administrators). This ensures secure login and appropriate permissions for each user role.
- **Inventory Tracking:** Provide a centralized catalog of all hardware devices with details like category and status. Devices are categorized (for example, general equipment, sensitive devices, or customer NDA-bound devices) and their availability status is tracked (e.g. *Available*, *Pending*, *Checked Out*, *Retired*). The system should allow easy lookup of device information and real-time status updates.
- **Request Management:** Implement a device request workflow where users can browse inventory and submit requests to borrow devices. Users should be able to create new requests (and modify or withdraw them if needed), while administrators can review incoming requests and **approve or reject** them. The system will also allow admins to attach or upload relevant documentation (such as approval forms or NDA files) to a request for record-keeping.
- **Transaction Logging:** Automatically log all device check-out and check-in transactions. Every time a device is issued to a user or returned to inventory, the action is recorded with details (who, when, what device) to maintain an audit trail. This provides accountability and a history of inventory usage over time.

These objectives ensure that the IMS will streamline the entire lifecycle of hardware inventory management, from user access and device tracking to request approvals and record-keeping.

## Technical Stack

The Inventory Management System is built with a modern web stack and tools to meet the project requirements:

- **Frontend:** Developed with **React** for a dynamic, component-based user interface. Styling is done using **Tailwind CSS** for rapid UI development and consistency, and the project leverages the **shadcn/ui** component library (a collection of pre-built React components) to speed up UI development and ensure accessibility.
- **Backend:** Built on **Node.js** using the **Express.js** framework to create a RESTful API service. The backend uses **PostgreSQL** as the relational database to store all persistent data, interfacing with it through **Prisma ORM** for convenient database migrations and type-safe queries.
- **Cloud Storage:** Integrated with **DigitalOcean Spaces** (an S3-compatible cloud storage) to handle file storage needs. This is used for storing uploaded files such as device images or attached documents (e.g. uploadable forms for requests) outside the database.
- **Architecture & Security:** The system follows a **RESTful API architecture**, with clear separation between client and server. **JWT (JSON Web Tokens)** are used for authentication and authorization, ensuring secure, stateless session management for users. Configuration secrets and environment-specific settings are managed via a `.env` file on both the backend and frontend, allowing secure and flexible deployment of database credentials, API keys (for DigitalOcean), JWT secret keys, and other settings without hardcoding them in the codebase.

## Features

The Inventory Management System offers several major features, each aligning with the course project requirements and demonstrating key technical competencies:

- **User Accounts & Authentication:** Users can register for an account and log in securely. The system hashes passwords and uses JWT tokens to maintain sessions. This feature meets the course requirement for implementing a secure user authentication system with persistent user accounts and session management.
- **Role-Based Access Control:** The application enforces different privileges based on user roles. **Administrators** have access to management functionalities (like adding devices or approving requests) that regular users do not. Regular users can view available inventory and make requests, but cannot directly alter inventory records. This fulfills the requirement for implementing multi-level access control in the system, ensuring sensitive operations are restricted to authorized personnel.
- **Inventory Management:** Administrators can add new devices to the inventory database, update device information, and categorize devices by type. All users (depending on permissions) can view the list of devices with key details like device name, type/category, and current status (available, checked out, etc.). This feature demonstrates the use of a **relational database and ORM** to perform typical Create, Read, Update, Delete (CRUD) operations on inventory records, satisfying the requirement for persistent data storage and management.
- **Device Request Workflow:** The system implements a full request-and-approval cycle for borrowing devices. A regular user can submit a **Device Request** through the interface by selecting a device (or specifying the type of device needed). They can also view the status of their requests or cancel a pending request. On the admin side, an **Admin Request Management** interface shows all pending requests; admins can review each request and either approve or reject it. During approval, an admin may assign a device (if not already specified) and upload any required documentation (for example, an NDA file or checkout form) which gets stored via DigitalOcean. This feature fulfills the course requirement for implementing a **multi-step workflow** (user request submission and admin approval) and showcases interaction between front-end forms, back-end logic, and file storage integration.
- **Transaction Logging (Audit Trail):** Every device check-out (approval of a request) and check-in (return of a device) is recorded in a **Transaction log** in the database. This includes details such as the device ID, the user who took or returned it, timestamps, and any relevant status changes. Administrators can use this log to audit the history of each device (who has used it and when) and to generate reports of inventory usage. This feature meets the requirement for maintaining an **audit trail** or history in the application, demonstrating an additional level of functionality beyond basic CRUD – it highlights back-end logic for automatically recording events and ensuring accountability for inventory movements.

Each of the above features has been implemented to satisfy project requirements and to ensure the system is comprehensive. Together, they cover essential aspects like authentication, authorization, persistent storage, workflow management, and logging, which were expected in the course project specifications.

## User Guide

This section outlines how users (both regular users and administrators) interact with the Inventory Management System. The application provides distinct pages and views depending on the user’s role.

### Regular User Pages

- **Login Page:** Allows an existing user to sign into the system using their credentials (email and password). Upon successful login, a JWT is issued and stored (e.g. in local storage or a cookie) to maintain the session. Users must be logged in to access any other page.
- **Registration Page:** Allows a new user to create an account by providing necessary information such as name, email, and password. After a successful registration, the user can log in with their new credentials.
- **My Devices Page:** A dashboard page for the logged-in user that lists any devices currently checked out to them or associated with their account. For example, if the user has an approved request (a device they have borrowed), it will appear here with details like device name and return date. If the user has no devices checked out, this page may indicate that no devices are currently assigned to them. This page helps users track what hardware they are responsible for.
- **Request Device Page:** This page lets a regular user browse or search the inventory and submit a request to borrow a device. The user can typically select a device (or device type), provide details like the reason or duration of the loan (if required), and then send the request. The page will show a form for entering request details and possibly the availability status of devices. After submission, the request will be pending admin approval. The user can later check back to see if their request is approved or cancel the request if it’s no longer needed.
- **Profile Page (User):** Displays the user’s profile information and account details. This typically includes their name, email, role (e.g. *User*), and possibly options to update their password or other info. It allows users to verify their account information and make changes to their personal details if that feature is supported. (Any sensitive changes may require re-authentication.)

### Administrator Pages

- **Admin Device Management Page:** This page is an inventory management interface for administrators. It shows the entire list of devices in the system along with their details (name, category/type, status, etc.). Administrators can add new device entries via a form (specifying details like device name, type, serial number, etc.), edit existing device information (for example, update the status to *Retired* if a device is decommissioned), or remove devices that are no longer in use. The page likely provides controls for these actions (such as an “Add Device” button or edit/delete icons next to each device). Changes made here update the PostgreSQL database via the backend API.
- **Admin Request Management Page:** This page allows administrators to review and manage all device requests submitted by users. It typically displays a list of pending requests with details like the requester’s name, the device requested, and the date of request. An administrator can click on a specific request to see full details and then choose to **approve** or **reject** the request. If approving, the admin might select which device to allocate (if the request was for a type of device rather than a specific item) and can upload any relevant file (e.g. a signed agreement or checkout form) to attach to the request record. Upon approval, the system logs the transaction (device checked out to the user) and updates the device’s status to *Unavailable/Pending* (depending on whether the user needs to take further action). If rejecting, the admin can provide a reason for rejection. The admin request page helps ensure all user requests are addressed and processed in a timely manner.
- **Admin Profile Page:** Similar to the user profile, this page displays the administrator’s own account information (name, email, role as *Admin*). In many implementations this page may also list some admin-specific info, such as an overview of actions they can perform or system stats, but primarily it confirms the admin’s credentials. The admin can update personal details or password here if allowed. Essentially, it’s the account management page for the administrator.

**Note:** The user interface is designed to be intuitive. Regular users only see the pages relevant to them (e.g. they will not see the admin pages), whereas administrators have access to the additional admin sections. Navigation links or a sidebar menu are typically provided to help users switch between pages (for example, an admin might have menu items for “Manage Devices”, “Manage Requests”, and “Profile”, while a regular user might see “My Devices”, “Request Device”, and “Profile”). All actions on these pages trigger requests to the backend API, and feedback (success messages, errors, etc.) is provided so that the user knows the result of each action.

## Development Guide

Follow these steps to set up the project for development and testing on a local machine:

1. **Clone the Repository:** Begin by cloning the project’s Git repository to your local machine using `git clone <repository_url>`. This will create a local project folder containing both the frontend and backend code.
2. **Backend Configuration:** Navigate into the backend project directory (e.g. `cd backend/`). Create a copy of the example environment file (if provided) or create a new file named `.env`. In this file, set up the required environment variables:
   - **Database URL:** Provide the PostgreSQL connection string (including username, password, host, port, and database name). For example: `DATABASE_URL="postgresql://user:password@localhost:5432/inventory_db"`.
   - **JWT Secret:** Set a secret key for JWT signing (e.g. `JWT_SECRET="your_jwt_secret_key"`).
   - **DigitalOcean Keys:** If the application uses DigitalOcean Spaces for file storage, provide the necessary config such as `DO_SPACES_KEY`, `DO_SPACES_SECRET`, the Space region, and bucket name (as specified by the project). These will allow the backend to connect to the cloud storage.
   - (Other variables like server port can be set here as well, if not defaulted to 3000).
3. **Install Backend Dependencies:** Run `npm install` in the backend directory to install all Node.js dependencies (Express, Prisma, etc.). Ensure you have Node.js (and npm) installed on your system.
4. **Database Setup:** Make sure you have a PostgreSQL server running and accessible (according to the credentials in your `.env`). If the database specified does not exist yet, create it using a PostgreSQL client or command-line. After that, use **Prisma** to set up the database schema:
   - Run `npx prisma generate` to generate Prisma client (if needed).
   - Run `npx prisma migrate dev --name init` to apply the initial database migrations. This will create the necessary tables (such as Users, Inventory, DeviceType, Requests, Transactions) in the PostgreSQL database according to the schema. If migrations are not set up, alternatively run `npx prisma db push` to push the schema state to the database.
5. **Run the Backend Server:** Start the Express server by running `npm run dev` (for a development server with reloading) or `npm start` in the backend directory. The backend should start on **http://localhost:3000** (unless a different port is configured in the environment). You should see console logs confirming the server is running and connected to the database. At this point, the REST API is ready (endpoints for login, requests, etc. are live).
6. **Install Frontend Dependencies:** Run `npm install` in the frontend directory to install all required packages (React, Tailwind, shadcn/ui components, etc.).
7. **Run the Frontend Dev Server:** Start the React development server by running `npm run dev`. By default, this will launch the app on **http://localhost:5174** (in a Vite development environment). The terminal will output the exact local address where the app is running.
8. **Access the Application:** Open a web browser and navigate to `http://localhost:5174`. You should see the login page of the Inventory Management System. From here, you can register a new user or log in with an existing account to start using the system. The frontend will communicate with the backend API (running on port 3000) for all data operations. 

If all steps were followed correctly, you now have the IMS running locally. You can test various features (create accounts, add devices, make requests, etc.) and see the results immediately. During development, both the backend and frontend will live-reload on code changes, which aids in fast iteration.

## Deployment Information

This application is **not currently deployed** to a cloud hosting platform; it is intended to be run locally for the purposes of the course project. Both the backend and frontend run on the developer’s machine on their respective ports (3000 for the server API and 5174 for the web client). 

To use the system, the backend should be running in one terminal (listening on `localhost:3000`) and the frontend in another (serving the React app on `localhost:5174`). Then, accessing the frontend URL in a browser will allow you to interact with the application, while it sends API calls to the local backend. If deployment were required in the future, the team would consider deploying the backend (Express/Node.js) on a platform like Heroku or DigitalOcean App Platform and hosting the frontend as a static site (for example, on Vercel or GitHub Pages), configuring the API base URLs accordingly. For now, all testing and usage are done on the local environment.

## Individual Contributions

Each team member contributed to different aspects of the project. The table below outlines the primary responsibilities of each member:

| Team Member       | Responsibilities                                                   |
| ----------------- | ------------------------------------------------------------------ |
| **Yang Chen**     | Implemented the backend RESTful API using Express.js; designed and structured the relational database schema with **Prisma** and PostgreSQL; handled core backend logic and integration between the database and API routes. |
| **Yihang Lin**    | Led frontend development using **React**; built the main user-facing pages such as the Login, Registration, and My Devices pages; integrated frontend forms and components with backend API calls to ensure a smooth user experience. |
| **Yilei Ji**      | Focused on UI/UX design and styling across the application using **Tailwind CSS** and **shadcn/ui** components; trim UI/UX details based on peer review; Connect and test backend APIs to frontend to ensure all features worked; drafted project report as README.md file |
| **Chujing Yu**    | Developed the user authentication system with **JWT** and implemented authorization middleware on the backend to protect routes; integrated **DigitalOcean Spaces** for file storage (handling file upload and retrieval in request management); managed environment configuration and deployment scripts, and performed testing/debugging across the application. |

## Lessons Learned and Concluding Remarks

Working on the Inventory Management System provided our team with valuable lessons in both software development and collaboration. On the technical side, we gained hands-on experience with setting up a **full-stack web application** from scratch. Implementing the Express.js and React architecture taught us how to define clear API contracts and handle data flow between the frontend and backend. We learned to use **Prisma ORM** for database migrations and found it greatly simplified interactions with PostgreSQL, although we also had to troubleshoot schema design issues and ensure relational integrity (for example, linking users, devices, and requests in the data model). Integrating JWT-based authentication was another important learning outcome – we now better understand how to implement secure login systems and protect routes in a React app. Additionally, working with new tools like Tailwind CSS and the shadcn/UI component library improved our front-end design skills and showed us how quickly a consistent interface can be built with the right tools. We also encountered challenges such as managing CORS between the frontend and backend during development and dealing with asynchronous state updates in React, all of which improved our problem-solving skills and knowledge of debugging techniques.

From a teamwork perspective, this project reinforced the importance of communication and division of labor in software development. We began by clearly defining each member’s roles (frontend vs. backend focus areas) and establishing a common understanding of the project objectives. Throughout the development process, we used version control (Git) and issue tracking to coordinate our work. This taught us how to handle **merge conflicts** and integrate features developed in parallel. We held regular team meetings to synchronize on progress, which helped in catching integration problems early – for instance, adjusting our API endpoints or data formats to match on both sides. The collaboration also highlighted the value of writing clear documentation and commit messages for each other’s benefit. We learned to adapt to each other’s coding styles and to review code collectively, which not only improved code quality but also spread knowledge among the team about all parts of the codebase. Overall, the experience improved our ability to work as an effective engineering team, mirroring real-world software projects.

In terms of future improvements, there are several areas we identified. Given more time, we would implement a more robust notification system – for example, sending email alerts or in-app notifications to admins when a new device request is submitted, and to users when their request is approved or rejected. We also recognize the need for more comprehensive **testing** (both unit tests and integration tests) to ensure reliability; setting up an automated test suite and CI/CD pipeline would be a logical next step to improve code confidence. Additionally, there are opportunities to refine the user interface and experience: we could add search and filtering capabilities to the inventory and request tables, and further polish the responsive design for use on mobile devices. Another potential enhancement is to implement finer-grained roles or permissions (for instance, a role for inventory managers separate from super-admins) if the organization grows. Finally, deploying the application on a cloud platform and using real production data would be a valuable step to observe how the system scales and performs under real-world load, and to gather feedback from actual users.

**Concluding Remarks:** The Inventory Management System project successfully met our initial objectives of simplifying hardware inventory operations. We delivered a functional application that demonstrates key concepts from our course – including full-stack development, database integration, user authentication, and cloud service usage. Beyond the technical fulfillment, this project was a great learning journey. It allowed us to apply theoretical knowledge in practice and understand the nuances of building a complete software system. Each team member’s contributions and the synergy between frontend and backend development were crucial in making the project a success. In conclusion, we are proud of the system we built and the skills we honed along the way. This project has prepared us to take on even more complex development tasks in the future, and the lessons learned will be invaluable in our careers ahead.